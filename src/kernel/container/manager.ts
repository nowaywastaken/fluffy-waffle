import { spawn, exec } from 'child_process';

/**
 * Container Manager
 * Handles L2 sandbox lifecycle using Docker/Podman CLI.
 * 
 * Responsibilities:
 * 1. Create sandboxes (run containers)
 * 2. Monitor status
 * 3. Cleanup (destroy)
 */

export type SandboxState = 'creating' | 'running' | 'stopping' | 'cleanup' | 'destroyed' | 'failed';

export interface SandboxConfig {
  plugin_name: string;
  container_id: string; // Unique ID generated by Kernel
  image: string;
  mounts: { source: string; target: string; readonly: boolean }[];
  env?: Record<string, string>;
  network_mode: 'none' | 'restricted';
  memory_limit: string;
  cpu_limit: number;
}

export class ContainerManager {
  private runtime: string = 'docker'; // Default, detected by Bootstrap

  constructor(runtime: string) {
    this.runtime = runtime;
  }

  public async createSandbox(config: SandboxConfig): Promise<string> {
    // Construct CLI command
    // docker run -d --name <id> --network <mode> --memory <limit> ...
    
    const args = [
      'run', '-d',
      '--name', config.container_id,
      '--network', config.network_mode === 'restricted' ? 'bridge' : 'none', // restricted needs proxy
      '--memory', config.memory_limit,
      '--cpus', config.cpu_limit.toString(),
      '--rm', // Auto-cleanup on exit for now, maybe change for debug
      '--init', // Use init process to reap zombies
      // Security hardening
      '--security-opt', 'no-new-privileges',
      '--read-only', // Read-only rootfs
      '--cap-drop', 'ALL', // Drop all capabilities
    ];

    // Add mounts
    for (const mount of config.mounts) {
      args.push('-v', `${mount.source}:${mount.target}:${mount.readonly ? 'ro' : 'rw'}`);
    }

    // Add env vars
    if (config.env) {
      for (const [key, val] of Object.entries(config.env)) {
        args.push('-e', `${key}=${val}`);
      }
    }

    // Image
    args.push(config.image);

    return new Promise((resolve, reject) => {
      const child = spawn(this.runtime, args);
      let stdout = '';
      let stderr = '';

      child.stdout.on('data', (d) => stdout += d.toString());
      child.stderr.on('data', (d) => stderr += d.toString());

      child.on('close', (code) => {
        if (code === 0) {
          resolve(stdout.trim()); // Returns container ID
        } else {
          reject(new Error(`Failed to create sandbox: ${stderr}`));
        }
      });
    });
  }

  public async stopSandbox(containerId: string): Promise<void> {
    await this.runCommand('stop', [containerId]);
  }

  public async killSandbox(containerId: string): Promise<void> {
    await this.runCommand('kill', [containerId]);
  }

  public async removeSandbox(containerId: string): Promise<void> {
    await this.runCommand('rm', ['-f', containerId]);
  }

  public async inspectSandbox(containerId: string): Promise<any> {
    const output = await this.runCommand('inspect', [containerId], true);
    if (typeof output === 'string') {
      return JSON.parse(output);
    }
    throw new Error('Failed to inspect sandbox: no output');
  }

  private async runCommand(cmd: string, args: string[], captureOutput = false): Promise<string | void> {
    return new Promise((resolve, reject) => {
      exec(`${this.runtime} ${cmd} ${args.join(' ')}`, (error, stdout, stderr) => {
        if (error) {
          reject(new Error(`Command failed: ${stderr || error.message}`));
        } else {
          resolve(captureOutput ? stdout : undefined);
        }
      });
    });
  }
}
